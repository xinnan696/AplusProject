# 后端功能模块需求设计

1. **User Authentication Module**
    
    用户身份验证、登录、注册、密码找回、Token 管理等功能。
    
2. **Signal Control Module**
    
    控制仿真中的信号灯状态，可接受 AI 或人工控制指令，并通过 TraCI 模块与 SUMO 引擎交互。
    
3. **Traffic Sensing Module**
    
    负责定期从Redis中采集车道数据，如速度、车辆数量、排队长度等。
    
4. **AI Intelligence Module**（合并了 AI 推理 + 本地 AI 控制）
    
    调用远程 AI 模型服务或本地规则进行信号相位推荐。
    
5. **Special Event Handling Module**
    
    模拟紧急事件（事故、封路、特殊车辆通行等），定时触发或前端控制，动态干预仿真。
    
6. **Logging and Audit Module**
    
    记录所有操作日志与系统行为日志，支持审计、安全追踪与前端可视化展示。
    
7. **Status Sync Module**（状态同步模块）
    
    统一收集各模块的系统状态数据，并通过 REST API 和 WebSocket 实时推送给前端，
    
    使用 Kafka 接收异步状态消息，保障高吞吐与解耦。
    

---

### **1. User Authentication Module**

**功能目标：**

- 实现用户的安全登录、身份验证和密码管理功能；
- 支持“忘记密码”与邮件验证码验证机制；
- 管理用户登录状态和系统访问权限，保障系统安全边界。

---

**功能需求：**

- 提供用户通过用户名/邮箱 + 密码登录的功能，返回访问令牌（JWT）；
- 支持“忘记密码”流程，包括邮箱验证与密码重置；
- 设置登录失败次数限制与账号锁定机制；
- 提供 Token 验证与权限校验逻辑；
- 所有登陆行为应记录至日志系统以供审计。

---

**输入输出：**

| **功能接口** | 请求类型 | **输入参数** | **输出结果** | 备注 |
| --- | --- | --- | --- | --- |
| 登录 /api/auth/login | POST | userID, password | 成功：JWT token + 用户信息；失败：错误码与提示消息 |  |
| 忘记密码 /api/auth/forgot-password | POST | email | 成功：发送成功提示；失败：邮箱无效或未注册 |  |
| 重置密码 /api/auth/reset-password | POST | email, token, new password | 成功：密码重置成功提示；失败：token 无效或过期 |  |
| Token 校验 /api/auth/verify-token | GET | JWT token | 成功：用户 ID 与权限信息；失败：401 Unauthorized 错误 |  |

---

**约束条件：**

- 密码必须进行加密存储（bcrypt）；
- 登录失败超过 3 次后，锁定账号 5 分钟；
- 邮箱验证与重置流程需异步处理，防止阻塞主线程；
- 所有返回统一 JSON 格式：statusCode, message, timestamp；
- 使用 JWT 管理用户状态，后端不保存会话信息（stateless）。

---

**对接前端模块：**

- 登录界面 Login Page；
- 忘记密码页面 Forgot Password；
- 重置密码 Reset Password；
- 管理控制台和后台访问控制界面（通过 Token 校验身份）。

---

**数据来源：**

- 用户提交的注册、登录、重置请求信息（用户ID、邮箱、密码）；
- 系统生成的重置 token、验证码等；
- 邮件服务平台（SMTP 或 SendGrid）用于发送验证码或链接。

---

**与其他模块交互：**

- **与 Logging and Audit Module：**
    
    所有认证相关行为（登录、登出、失败、密码重置）通过本模块发起异步日志记录调用，调用方式为 RESTful POST 接口，通过消息队列（Kafka）异步推送操作日志。日志模块负责统一落库与审计。
    
- **与系统网关模块（Nginx）：**
    
    在系统部署层，API 网关会拦截请求并校验是否附带有效 Token。认证模块通过 JWT 的公钥验证机制与系统对接，Token 签发使用 RS256 等非对称加密确保安全性。（这部分开发阶段可以先暂时不实现）
    
- **与所有需权限验证的后端模块：**
    
    每次请求中，前端携带 JWT Token，通过 verify-token 接口进行后端身份验证。通过 Spring Boot 的全局 Filter 拦截处理，解析 token 并将用户身份上下文注入 SecurityContext，供后续业务模块识别当前操作者。
    
- **数据传输机制：**
    
    所有认证与验证相关的数据通过 HTTPS 加密传输，接口统一使用 RESTful API，响应数据使用 JSON 格式。敏感操作如密码重置链接使用 token + 过期机制防止滥用。
    

---

**数据库表交互：**

| **表名** | **说明** |
| --- | --- |
| users | 存储用户信息：user_id, username, email, hashed_password, role, status 等字段。 |
| user_auth_logs | 记录认证操作，如登录、登出、失败尝试，包含 IP、时间、状态码等。 |
| password_resets | 存储密码找回流程的请求记录，含邮箱、验证码或 token、创建时间、是否使用等。 |
| operation_logs | 统一操作日志表，用于记录所有认证相关的重要行为，供后台审计模块查询。 |

---

### **2. Signal Control Module**

**功能目标：**

- 接收来自用户或 AI 模块的信号控制请求
- 将控制请求发送至 TraCI控制模块
- 反馈执行结果，并通过 Kafka 发布状态消息至 Status Sync Module

---

**功能需求：**

- 提供 REST API 接口，接收用户操作或 AI 模块发送的红绿灯控制指令
- 校验请求合法性（时间窗口、当前仿真状态）
    - 解释
        
        确保**前端或AI发来的控制请求在合适的时机、安全地作用于SUMO仿真引擎**，避免无效控制、冲突控制或系统错误。
        
        ### **校验的两个关键维度**
        
        ### **1.时间窗口校验（Time Window Validation）**
        
        - **目的**：避免高频/非法时间段内发起控制请求，保证每个红绿灯控制周期有充分执行时间。
        - **校验内容**：
            - 当前距离上一次控制是否满足最小时间间隔（间隔 < 5s 则拒绝）；
            - 该路口是否正处于“允许外部控制”的时间窗口（如夜间不允许AI控制）。
        - **实现方式**：
            - 在数据库及Redis中维护每个路口最近一次控制时间 last_control_time；
            - 在接收控制请求时对比当前时间与Redis中该时间差值；
            - 如果超出允许频率，返回错误码（429 Too Frequent）；
            - 如果处于受限控制周期（如AI托管模式），返回 403 Forbidden。
        
        ### **2.仿真状态校验（Simulation State Validation）**
        
        - **目的**：确保当前 SUMO 正在运行并连接中，避免控制请求落空或抛出异常。
        - **校验内容**：
            - 是否成功连接 SUMO 的 TraCI 接口（客户端有效）；
            - SUMO 当前是否处于“正在运行状态”而不是“初始化”或“已结束”状态；
            - 控制目标路口是否存在，信号灯 ID 是否可识别；
        - **实现方式**：
            - 在控制模块中调用TraCI模块接口获取SUMO的启动状态并写入Redis中；
            - 每次控制前调用 isSimulationActive() 方法判断连接状态；
            - 若异常（如连接断开或正在重启），则返回 503 Service Unavailable；
            - 同时校验控制参数中的 tl_id 是否存在于 tl_logic 表或Redis缓存中。
        
        ---
        
        ### **为什么必须做这些校验？**
        
        | **校验目标** | **避免的风险** | **效果** |
        | --- | --- | --- |
        | 时间窗口校验 | 控制过于频繁导致状态混乱、仿真不稳定 | 限流，保证控制间隔 |
        | 仿真状态校验 | SUMO 未连接、仿真未启动导致控制失效或抛错 | 稳定性、错误提示准确 |
        | 参数合法性校验 | 控制非法路口、非法 phase 导致仿真异常或无响应 | 系统鲁棒性提升 |
- 调用 TraCI 模块完成信号灯state的设置
- 反馈控制结果（成功 / 失败 / 异常信息）
- 将控制结果封装为状态消息发送至 Kafka，由 Status Sync 模块消费并推送给前端

---

**输入输出：**

| **功能接口** | **请求类型** | **输入参数** | **输出结果** | **备注** |
| --- | --- | --- | --- | --- |
| /api/signalcontrol/manual | POST | {junctionId（信号灯ID）phaseId（相位编号）duration（持续时间）,LinkIndex, state, source=manual} | {code, message, body} | 手动控制入口；前端用户进行人工信号灯调整 |
| /api/signalcontrol/ai | POST | {junctionId（信号灯ID）phaseId（相位编号）duration（持续时间）,LinkIndex, state, source=ai} | {code, message, status}（如 200 / 403 / 503 等） | AI 推理结果应用接口，需进行仿真状态、时间窗口等校验 |

---

**约束条件：**

- 操作必须在仿真运行状态中执行，且不能对已处于控制中的路口重复控制
- 控制逻辑必须具备幂等性（即多次相同指令不会重复造成干扰）
- 所有状态变化必须上报给 Status Sync 模块，确保前端状态一致性

---

**对接前端模块：**

- Manual Control 功能
- AI Recommended Actions 显示区域
- 控制状态实时地图（通过 WebSocket 展示）

---

**数据来源：**

- AI Intelligence Module 通过 HTTP POST 发送控制建议
- Manual Control 页面通过用户操作触发 REST API 调用
- AI Recommended Actions 功能用户触发“APPLY”调用

---

**与其他模块交互：**

| **交互模块** | **交互方式** | **数据类型 / 协议** | **说明** |
| --- | --- | --- | --- |
| **AI Intelligence Module** | HTTP 请求 | JSON 控制请求 | AI 发起控制决策 |
| **Status Sync Module** | Kafka 消息队列 | JSON 状态事件 | 发布控制状态供前端展示 |
| **Logging and Audit Module** | 异步日志写入 | 内部调用 / 事件发布 | 记录所有人工或 AI 控制行为 |

---

**数据库表交互：**

| **表名** | **说明** |
| --- | --- |
| traffic_light_controls | 记录所有红绿灯控制指令（时间、来源、相位、结果） |
| traffic_light_status | 记录当前每个路口的最新信号状态（供其他模块查询） |
| operation_logs | 通过日志模块记录人工控制或 AI 控制行为，供审计与可视化 |

---

### **3. Traffic Sensing Module**

**功能目标**

- 定时从Redis批量读取所有车道、路口和信号灯的实时状态快照。
- 统一完成对各类交通感知数据的加工、聚合、统计（如：近5分钟流量、平均速度、拥堵次数等）。
- 聚合/统计后的指标批量写入MySQL，供报表与Dashboard使用。

---

**功能需求**

- 异步定时任务定期批量拉取Redis的所有实时状态，计算历史趋势、统计指标等。
- 聚合逻辑灵活可配置，支持不同统计窗口（如5分钟、1小时、1天）。
- 聚合结果、原始历史快照统一批量写入MySQL归档表，支持分表/分区。
- 提供内部数据接口，供Status Sync Module或后端其他模块查询聚合/历史数据。

---

**输入输出**

- **输入：**Redis缓存中的路口、车道、信号灯实时数据
（speed, vehicle_count, queue_length）
- **输出：**聚合后写入MySQL的历史、趋势、统计表（如traffic_agg_hourly, traffic_lane_history等）。

---

**约束条件**

- 异常情况（如 TraCI 连接失败）应记录至日志表并重试处理（待定）。
- REST接口如检测到Redis未更新（如数据超时）需及时响应错误或“数据失效”提示
- 本模块不对外直接暴露REST API，只做数据加工与准备。
- 与Python采集模块、SUMO无直接耦合，仅通过Redis读数据。
- 聚合、归档任务异步解耦，生产环境推荐线程池/消息队列提升稳定性。

---

**对接前端模块（经由**Status Sync Module**）**

- Dashboard 所有实时和统计图表

---

**数据来源**

- Redis缓存中的实时数据，历史归档入MySQL

---

**与其他模块交互**

- **Status Sync Module**：通过MySQL聚合表提供历史与统计数据；通过Redis提供实时快照数据
- **Logging & Audit Module**：聚合和归档任务行为日志

---

**数据库表交互**

- 实时数据只存在于Redis，无需直接写DB
- 聚合历史数据定期批量写入MySQL的统计表（如traffic_lane_history、dashboard_agg_metrics等）

---

### **4. AI Intelligence Module**

### **功能目标：**

- 与独立部署的 AI 模型服务（Python + FastAPI）进行交互，获取交通信号灯控制策略；
- 实时接收交通感知模块的数据，根据路口状态调用推理接口；
- 推理结果下发至信号控制模块，并通过 Kafka 通知状态同步模块；
- 引入异步推理机制与 Redis 缓存，提升系统响应速度与稳定性。

---

### **功能需求：**

- 接收来自 Traffic Sensing Module 的当前路况数据；
- 调用 AI 模型服务的 REST 接口，获取推荐的信号灯控制策略；
- 判断模型可用性并在服务不可达时自动回退至默认策略；
- 将推理结果通过 Kafka 推送至状态同步模块；
- 推理日志记录至数据库，支持系统评估与可视化；
- 缓存热点路口的最新推理结果，避免重复计算；
- 异步执行推理任务，提升多路口响应效率。

---

**输入输出：**

- **输入：**
    - 路口=信号灯编号（junctionId）
    - 当前交通状态：包括每个车道的速度、排队长度、车辆数等
- **输出：**
    - 推荐信号相位编号（recommendedPhase）
    - 模型版本号、置信度（可选）、响应耗时
    - 推理是否成功的状态码

---

**约束条件：**

- 模型推理请求超时应小于 2 秒，超时需记录并 fallback；
- 同一时间只对同一路口进行一次推理请求；
- 所有推理调用必须写入日志表并触发状态推送；
- AI 模型服务挂掉不应影响主控系统运行；
- 推理结果缓存时效建议为 5–10 秒，热点路口可延长。

---

**对接前端模块：**

- AI Suggested Actions Module
- Dashboard 模块中的拥堵/决策建议图表展示

---

**数据来源：**

- Traffic Sensing Module：实时交通数据；
- AI Model Service（Python + FastAPI）：推理服务结果；
- Redis：缓存热点推荐值；
- Kafka：推理结果异步传输通道。

---

**与其他模块交互方式：**

| **模块** | **交互方式** | **内容** |
| --- | --- | --- |
| **Traffic Sensing Module** | 内部调用/订阅机制 | 提供路口实时交通状态 |
| **AI Model Service** | REST API 调用（JSON 格式） | 发送推理请求并接收推荐相位 |
| **Signal Control Module** | 内部方法或 REST 接口调用 | 发送推荐控制策略进行信号执行 |
| **Status Sync Module** | Kafka 推送（ai.recommendation.topic） | 推理结果发送至前端状态同步通道 |
| **Logging and Audit Module** | 数据库写入 | 所有推理行为、异常状态记录入库 |
| **Redis 缓存** | 读写缓存键值 | 缓存热点路口推理结果 |

---

**数据库表交互：**

（待更新）

---

### **5. Special Event Handling Module**

**功能目标：**

- 自动调度并控制特殊交通事件（如事故、封路、流量突增），用于模拟突发情况并验证系统响应能力。
- 接入封装的 **SUMO Python Module**，修改仿真状态以反映事件效果。
- 通过 Kafka 通知状态同步模块进行 WebSocket 推送，记录事件日志并支持后续分析。

---

**功能需求：**

- 启用定时任务从 special_event_params 表中读取事件配置；
- 每个任务调度周期：
    - 校验是否存在需触发的事件（基于时间、启用状态）；
    - 提交事件执行请求至 **SUMO Python Module**；
    - 等待异步回调或执行反馈，更新 special_event_triggers 表；
    - 发布 Kafka 消息通知 **Status Sync Module**；
    - 将事件行为写入日志模块用于审计与可视化；
- 支持故障恢复与异常记录，避免重复执行或主线程阻塞。

---

**输入输出：**

| **接口** | **输入参数** | **输出结果** | **说明** |
| --- | --- | --- | --- |
| 事件调度检查 | 当前系统时间 | 是否命中事件配置 |  |
| 发起事件执行请求 | event_type, target_edge, intensity, time | SUMO模块回执：success / fail / timeout | 非对外API，定时调用
 |
| Kafka 消息发布 | 事件状态变更信息 | 状态同步模块实时推送 WebSocket |  |
| 日志写入 | 事件ID、结果、时间、响应信息 | 是否写入成功（异步） |  |

---

**约束条件：**

- 所有事件触发均由系统自动完成，**不提供前端或手动触发接口**；
- 每轮任务调度最多执行一个事件，避免状态冲突；
- 必须考虑事件间的空间/时间冲突，执行前进行验证；
- 与 TraCI 控制Module 通信必须具备异常处理与超时控制；
- 所有 I/O 操作应以 **异步非阻塞模式执行**，任务调度器只负责 **调度与请求发出**，真正执行与反馈处理由子线程完成；
- 状态更新需带时间戳，并确保仅更新一次。

---

**对接前端模块：**

- 无前端主动调用，Status Sync Module将事件结果推送给前端页面用于地图展示与事件图表更新。

---

**数据来源：**

- **special_event_params**：系统初始化时配置，可手动写入或通过管理脚本配置；
- **系统时间**：通过定时任务框架（如 @Scheduled, Quartz）驱动执行；
- **SUMO Python Module**：通过 REST API 调用仿真引擎控制接口；
- **Kafka**：用于状态通知与系统联动。

---

**与其他模块交互：**

| **对接模块** | **通信方式** | **说明** |
| --- | --- | --- |
| SUMO Python Module | HTTP（POST JSON） | 提交事件控制请求，控制路段关闭、流量增加等仿真行为 |
| Status Sync Module | Kafka Topic | 发布事件触发与执行结果，供前端订阅更新 UI |
| Logging & Audit | Async API Call | 写入事件调度与执行日志，异步调用，避免主流程阻塞 |

---

**数据库表交互：**

1. **special_event_params** — 事件模板配置表：
2. **special_event_triggers** — 执行记录表：

---

### **6. Logging and Audit Module**

**功能目标：**

- 统一收集、存储并查询系统中用户与系统模块产生的关键操作记录。
- 为故障排查、安全审计与用户行为分析提供基础支撑。
- 接口高并发友好，支持异步写入机制，避免对主流程的性能影响。

---

**功能需求：**

- 提供通用日志写入接口（供各模块调用）：记录操作人、操作内容、执行状态、来源模块等；
- 提供分页、过滤、导出接口：支持基于用户、模块、时间范围筛选；
- 日志类型包括但不限于：
    - 信号灯控制操作（人工 / AI 控制）；
    - 用户登录、登出、密码重置等行为；
    - 特殊事件的触发与执行；
    - AI 推理结果的接收与执行；
    - 系统异常信息（如 AI 服务异常响应等）；
- 自动写入部分操作日志（例如定时任务执行、Kafka 推送失败等）；
- 为前端 Records 页面与管理后台提供 RESTful 查询接口；
- 所有写入操作采用 **异步方式处理**（线程池 / 消息队列）。

---

**输入输出：**

| **功能项** | **输入字段** | **输出字段 / 结果** |
| --- | --- | --- |
| 写入操作日志 | operator_id, role, module, action, result, timestamp, details | 状态码（200 / 500），异步记录写入任务ID |
| 查询操作日志 | 时间范围、操作人、模块类型、关键字、分页参数 | 日志记录分页列表（含时间、内容、来源等） |
| 导出日志数据 | 筛选条件、导出格式（JSON / CSV） | 文件下载链接 / 数据流响应 |

---

**约束条件：**

- 所有关键操作必须带有 **模块来源字段** 与 **操作时间戳**，便于前后行为关联；
- 所有用户发起的操作必须写入 operator_id 和 role 字段，确保责任可追溯；
- 系统模块产生的日志需标记 system_generated = true；
- **不允许主流程直接写日志，必须异步执行**，写入失败将记录至错误缓冲区；
- 所有日志接口需做权限控制（如管理员查询他人日志）；
- 日志保留周期默认 90 天，可由配置修改。

---

**对接前端模块：**

- **Records 页面（操作记录、用户行为）**
- **管理员 Dashboard 中日志导出功能**
- **异常告警系统或可视化分析模块（如 Kibana）**

---

**数据来源：**

- 各后端功能模块：如 User Auth, Signal Control, AI Intelligence 等；
- Kafka 消息监听失败记录；
- 定时任务调度日志；
- AI 模型反馈异常、推理延迟超限等系统行为。

---

**与其他模块交互：**

| **对接模块** | **通信方式** | **描述** |
| --- | --- | --- |
| 所有后端核心模块 | 内部异步调用 | 提供统一 LogService.asyncWrite(log) 接口 |
| Kafka Listener（可选） | 异常捕获写日志 | Kafka 推送失败或状态异常时自动写入系统日志 |
| 管理前端 | REST API | 提供日志查询、导出、关键操作溯源等功能 |

---

**数据库表交互：**

（待更新）

---

### **7. Status Sync Module**

**功能目标：**

- 统一对外提供所有与系统状态相关的数据API，包括实时快照、历史聚合、Dashboard统计等。
- 支持REST API和WebSocket推送，满足前端所有数据需求。
- 作为唯一“对外出口”，统一数据安全、权限、日志追踪、接口格式。

---

**功能需求：**

- 消费来自 Kafka 的状态消息队列，解析各模块的状态更新事件。
- 将数据加工缓存至 Redis，用于快速响应前端轮询和状态订阅请求。
- 提供 REST API 接口用于前端历史数据访问与初始化加载。
- 提供 WebSocket 接口，向前端推送实时状态变更（如红绿灯状态、交通流量、AI 推荐相位、特殊事件）。
- 管理状态数据的时间戳与更新频率，保证系统一致性与前端渲染稳定。
- 实时数据接口：从Redis批量拉取最新的路口、车道、信号灯状态，聚合后通过REST或WebSocket推送前端。
- 历史/统计接口：从MySQL聚合历史表查询，返回Dashboard、趋势图所需的统计数据。
- 推送机制：支持前端订阅WebSocket，后台检测数据有变化时自动推送最新状态和统计结果。
- 统一接口规范：所有API返回统一JSON结构，带时间戳、状态码和说明。

---

**输入输出：**

- **输入**：
    - Redis中的实时快照（由**TraCI模块**持续写入）
    - MySQL中的聚合统计表（由Traffic Sensing Module定时写入）
- **输出**：
    - REST API（GET /api/status/realtime、/api/status/agg、/api/status/history等）
    - WebSocket推送结构化数据流

| **接口名称** | **类型** | **输入参数** | **输出参数** | **用途说明** |
| --- | --- | --- | --- | --- |
| /api/status/realtime | GET | junctionId/area/filter | 实时状态JSON | 地图、信号灯、拥堵、车流、状态 |
| /api/status/aggregate | GET | type, interval, range | 聚合指标列表（如各时段统计） | Dashboard趋势、折线、柱状、饼图 |
| /api/status/history | GET | junctionId, timeRange | 历史状态/变化序列 | 折线、历史对比、查询 |
| /api/status/event-log | GET | filter, page | 事件记录（如事故、特殊事件） | 事件列表、控制台、历史回放 |
| /api/status/ws | WS | 订阅条件 | 实时状态推送JSON流 | 实时地图、控制台、Dashboard等 |

| **类型** | **输入** | **输出** |
| --- | --- | --- |
| Kafka 消息 | 各模块状态变更事件（JSON 格式） | 消费后推送WebSocket |
| REST 查询 | 路口 ID / 数据类型 / 时间范围 | 当前状态快照 / 历史状态列表 |
| WebSocket 推送 | 状态更新信号（内部触发） | 推送 JSON 状态数据至订阅前端客户端 |

---

**约束条件：**

- 所有API接口必须高并发友好，聚合/历史查询有良好索引和分页。
- 状态推送频率可控（如每2秒一次），避免过载。
- 安全、鉴权与接口限流一站式统一。

---

**对接前端模块：**

- 所有需要状态、统计、趋势数据的页面/组件（Dashboard、地图、实时控制、日志展示等）

---

**数据来源：**

- Signal Control Module（红绿灯状态变更）
- Traffic Sensing Module（车道交通状态统计、聚合指标）
- AI Intelligence Module（AI 推荐结果、拥堵判断）
- Special Event Handling Module（事件触发状态、事件详情）
- Logging and Audit Module（可选辅助日志状态用于调试）

---

**与其他模块交互：**

- **方式：** 通过 Kafka 消费信号灯控制模块状态更新事件（信号灯控制模块 -> Kafka -> Status Sync Module）
- **传输协议：** Kafka 消息流传输 JSON 数据；Redis 用于缓存；WebSocket + REST 提供前端接口

---

**数据库表交互：**

不直接写入数据库，仅从 Redis 缓存和 Kafka 消息流中读取、处理状态数据用于前端同步。

Dashboard中需要展示的数据查询Mysql，必要时写入Redis中缓存。